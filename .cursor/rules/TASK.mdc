# 📋 챗봇 프로젝트 과제 수행 Task

이 문서는 챗봇 프로젝트를 처음부터 배포까지 완성하기 위한 단계별 가이드입니다.

**⚠️ 중요**: 이 프로젝트는 **Docker 기반 개발**을 필수로 합니다. 모든 개발 과정은 Docker 환경에서 진행되어야 합니다.

---

## ✅ Task 1: 환경 설정 및 초기 준비

### 1.1 필수 요구사항 확인

- [ ] **Docker Desktop 설치 및 실행 확인** (필수! 반드시 실행 상태 유지)
- [ ] Git 설치 확인
- [ ] 코드 에디터 준비 (VS Code 권장)
- [ ] OpenAI API 키 발급 (https://platform.openai.com/api-keys)

**⚠️ Docker Desktop 필수**: 이 프로젝트는 Docker 기반으로만 실행됩니다. Docker Desktop이 설치되어 있지 않으면 개발을 진행할 수 없습니다.

### 1.2 프로젝트 클론 및 초기 설정

```bash
# 프로젝트 클론 (이미 있다면 생략)
cd /Users/jeonsiwon/Desktop/3-chatbot-project

# .env 파일 생성
cp .env.example .env
```

### 1.3 .env 파일 설정

- [ ] `.env` 파일 열기
- [ ] `OPENAI_API_KEY=your_openai_api_key_here`를 실제 API 키로 교체
- [ ] 파일 저장

**완료 기준**: `.env` 파일에 유효한 OpenAI API 키가 설정됨

---

## ✅ Task 2: 챗봇 데이터 준비

### 2.1 챗봇 설정 파일 작성

- [ ] `config/chatbot_config.json` 파일 열기
- [ ] 챗봇의 정체성 설정:
  - `name`: 챗봇 이름
  - `description`: 챗봇 설명
  - `character`: 챗봇 성격/페르소나
  - `system_prompt`: 시스템 프롬프트 (챗봇의 역할 정의)

**예시**:

```json
{
  "name": "서강이",
  "description": "서강대학교 신입생 도우미",
  "character": "친근하고 유쾌한 선배",
  "system_prompt": "당신은 서강대학교의 친절한 선배입니다. 신입생들에게 학교 생활에 대한 정보를 알려주세요. 반말로 친근하게 대화하며, 이모지를 적절히 사용하세요."
}
```

### 2.2 텍스트 데이터 작성 (중요!)

- [ ] `static/data/chatbot/chardb_text/` 폴더에 지식 베이스 파일 작성
- [ ] **최소 50개 이상의 QA 쌍 또는 정보 문서 작성** (권장: 100개 이상)
- [ ] 파일 형식: `.txt`, `.json`, `.md` 자유롭게 사용 가능
- [ ] 다양한 카테고리로 분류하여 작성

**⚠️ 중요**: 데이터가 많을수록 RAG 성능이 향상됩니다. 최소 기준만 충족하지 말고 풍부한 지식 베이스를 구축하세요!

**예시 파일 구조**:

```
static/data/chatbot/chardb_text/
├── qa_general.txt          # 일반 질문-답변 (10개 이상)
├── qa_dining.txt           # 식당 관련 (10개 이상)
├── qa_facilities.txt       # 시설 관련 (10개 이상)
├── qa_academics.txt        # 학사 관련 (10개 이상)
├── qa_clubs.txt            # 동아리 관련 (5개 이상)
├── qa_events.txt           # 행사 관련 (5개 이상)
├── campus_info.md          # 캠퍼스 상세 정보
├── tips.txt                # 꿀팁 모음 (10개 이상)
└── faqs.txt                # 자주 묻는 질문 (10개 이상)
```

**예시 내용 (qa_dining.txt - 10개 이상 작성)**:

```
Q: 학식은 어디가 맛있어?
A: 곤자가가 제일 인기야! 돈까스랑 김치찌개가 특히 맛있어. 점심시간엔 줄이 길어서 11시 30분쯤 가는 게 좋아.

Q: 도서관은 몇 시까지 열어?
A: 로욜라 도서관은 평일 오전 9시부터 밤 10시까지 운영해. 시험 기간에는 12시까지 연장 운영하기도 해!

Q: 동아리는 어떻게 가입해?
A: 매 학기 초에 동아리 박람회가 열려. 그때 가면 여러 동아리를 구경하고 가입할 수 있어! 학생회관 게시판도 확인해봐.

Q: 학식 말고 주변에 맛집 있어?
A: 정문 앞에 '엄마손칼국수'랑 '김밥천국'이 가성비 좋아. 후문 쪽에는 '맥도날드'랑 카페들이 많아!

Q: 아침 학식도 해?
A: 응, 곤자가에서 아침 8시부터 9시 30분까지 조식 운영해. 토스트랑 죽 나오는데 가격도 저렴해!

Q: 학식 메뉴는 어디서 확인해?
A: 학교 공식 앱이나 학생식당 인스타그램에서 주간 메뉴 확인할 수 있어. 매주 월요일에 업데이트돼.

Q: 채식 메뉴도 있어?
A: 있어! 곤자가에서 채식 코너 따로 운영하고 있어. 샐러드바도 있으니까 걱정 마!

Q: 학식 카드 충전은 어디서 해?
A: 학생식당 입구나 학생회관 1층 무인기에서 충전할 수 있어. 현금이랑 카드 다 돼.

Q: 학식 가격은 얼마야?
A: 일반 식사가 4,000원 정도야. 학생 할인 받으면 3,500원! 엄청 저렴하지?

Q: 테이크아웃도 돼?
A: 응, 일회용 용기 가져가면 포장해줘. 용기는 100원인데 환경을 위해 개인 용기 가져가는 게 좋아!

(... 최소 50개 이상 작성하세요!)
```

**데이터 작성 팁**:

1. **구체적으로**: "좋아요" 보다는 "점심시간 12시에 가면 10분 대기해야 해요"처럼 구체적으로
2. **다양한 표현**: 같은 의미라도 다양한 표현으로 작성 (예: "학식", "학생식당", "식당")
3. **실제 경험**: 실제 학생들이 궁금해할 만한 내용 위주
4. **카테고리 분산**: 한 파일에 몰아넣지 말고 카테고리별로 분산
5. **감정 포함**: 단순 정보 전달이 아닌 선배의 조언 느낌으로

### 2.3 이미지 데이터 준비 (필수!)

**⚠️ 이미지 검색 기능은 필수 구현 사항입니다!**

- [ ] `static/images/chatbot/` 폴더에 챗봇 관련 이미지 **최소 10개 이상** 추가
- [ ] 각 이미지에 대한 메타데이터 작성
- [ ] 이미지 파일명은 의미있게 작성 (영문, 언더스코어 사용)

**필수 이미지 종류** (최소 10개):

```
static/images/chatbot/
├── campus_map.jpg          # 캠퍼스 지도
├── library_inside.jpg      # 도서관 내부
├── cafeteria_menu.jpg      # 학식 메뉴판
├── student_center.jpg      # 학생회관
├── gym.jpg                 # 체육관
├── dormitory.jpg           # 기숙사
├── classroom.jpg           # 강의실
├── cafe_area.jpg           # 카페 공간
├── entrance_gate.jpg       # 정문
├── club_poster.jpg         # 동아리 포스터
└── (추가 이미지들...)
```

**이미지 메타데이터 파일 작성**:

`static/data/chatbot/image_metadata.json` 파일 생성:

```json
{
  "images": [
    {
      "filename": "campus_map.jpg",
      "description": "서강대학교 캠퍼스 전체 지도",
      "keywords": ["지도", "캠퍼스", "위치", "건물", "찾아가기"],
      "category": "campus"
    },
    {
      "filename": "library_inside.jpg",
      "description": "로욜라 도서관 내부 열람실 모습",
      "keywords": ["도서관", "공부", "열람실", "조용한", "학습"],
      "category": "facilities"
    },
    {
      "filename": "cafeteria_menu.jpg",
      "description": "이번 주 학생식당 메뉴판",
      "keywords": ["학식", "메뉴", "식당", "밥", "식사"],
      "category": "dining"
    }
  ]
}
```

**완료 기준**:

- `chatbot_config.json` 설정 완료
- **최소 50개 이상의 지식 항목 작성 완료**
- **최소 10개 이상의 이미지 및 메타데이터 작성 완료**

---

## ✅ Task 3: ChatbotService 구현

**⚠️ 모든 구현은 Docker 환경에서 테스트하면서 진행하세요!**

### 3.1 기본 구조 이해

- [ ] `services/chatbot_service.py` 파일 열기
- [ ] 클래스 구조 파악:
  - `__init__`: 초기화
  - `_create_embedding`: 텍스트 → 벡터 변환
  - `_create_image_embedding`: 이미지 → 벡터 변환 (필수)
  - `_search_similar`: RAG 텍스트 검색
  - `_search_similar_image`: RAG 이미지 검색 (필수)
  - `_build_prompt`: 프롬프트 구성
  - `generate_response`: 응답 생성 (통합)

### 3.2 OpenAI Client 초기화 구현

```python
from openai import OpenAI
import os

def __init__(self):
    # OpenAI Client 초기화
    self.client = OpenAI(api_key=os.getenv("OPENAI_API_KEY"))

    # ChromaDB 클라이언트 초기화 (텍스트용)
    # (구현 필요)

    # ChromaDB 클라이언트 초기화 (이미지용 - 필수!)
    # (구현 필요)

    # 이미지 메타데이터 로드
    # (구현 필요)
```

**체크리스트**:

- [ ] OpenAI Client 초기화
- [ ] 환경 변수에서 API 키 로드
- [ ] 에러 핸들링 추가

### 3.3 ChromaDB 설정 및 텍스트 데이터 로드

```python
import chromadb
from chromadb.config import Settings

def __init__(self):
    # ... (이전 코드)

    # ChromaDB 클라이언트 초기화 (텍스트용)
    self.chroma_client = chromadb.PersistentClient(
        path="static/data/chatbot/chardb_embedding"
    )

    # 텍스트 컬렉션 가져오기 또는 생성
    self.text_collection = self.chroma_client.get_or_create_collection(
        name="chatbot_knowledge",
        metadata={"hnsw:space": "cosine"}
    )

    # 텍스트 데이터 로드 (최초 1회)
    self._load_text_data()
```

**체크리스트**:

- [ ] ChromaDB 클라이언트 초기화
- [ ] 텍스트 컬렉션 생성/로드
- [ ] 텍스트 데이터 읽기 및 임베딩 생성
- [ ] ChromaDB에 저장

**Docker에서 테스트**:

```bash
# Docker 컨테이너 실행
docker compose up --build

# 로그에서 데이터 로드 확인
# "Loaded XX text documents" 같은 메시지 확인
```

### 3.4 ChromaDB 이미지 컬렉션 설정 (필수!)

```python
def __init__(self):
    # ... (이전 코드)

    # ChromaDB 클라이언트 초기화 (이미지용)
    self.image_collection = self.chroma_client.get_or_create_collection(
        name="chatbot_images",
        metadata={"hnsw:space": "cosine"}
    )

    # 이미지 메타데이터 로드
    self._load_image_metadata()

    # 이미지 임베딩 생성 (최초 1회)
    self._load_image_data()
```

**체크리스트**:

- [ ] 이미지 전용 ChromaDB 컬렉션 생성
- [ ] `image_metadata.json` 파일 읽기
- [ ] 각 이미지에 대한 임베딩 생성
- [ ] ChromaDB에 저장

### 3.5 Embedding 생성 함수 구현

```python
def _create_embedding(self, text: str) -> list:
    """텍스트를 임베딩 벡터로 변환"""
    try:
        response = self.client.embeddings.create(
            model="text-embedding-3-small",  # 또는 "text-embedding-3-large"
            input=text
        )
        return response.data[0].embedding
    except Exception as e:
        print(f"Embedding 생성 실패: {e}")
        return None
```

**체크리스트**:

- [ ] OpenAI Embeddings API 호출
- [ ] 에러 핸들링
- [ ] 벡터 반환

### 3.6 이미지 Embedding 생성 함수 구현 (필수!)

```python
def _create_image_embedding(self, image_description: str, keywords: list) -> list:
    """이미지 설명과 키워드를 기반으로 임베딩 벡터 생성"""
    try:
        # 이미지 설명 + 키워드를 하나의 텍스트로 결합
        combined_text = f"{image_description} {' '.join(keywords)}"

        response = self.client.embeddings.create(
            model="text-embedding-3-small",
            input=combined_text
        )
        return response.data[0].embedding
    except Exception as e:
        print(f"이미지 Embedding 생성 실패: {e}")
        return None
```

**체크리스트**:

- [ ] 이미지 설명과 키워드 결합
- [ ] OpenAI Embeddings API 호출
- [ ] 에러 핸들링

**Docker에서 테스트**:

```bash
# 로그에서 이미지 임베딩 생성 확인
# "Generated embedding for image: campus_map.jpg" 같은 메시지 확인
```

### 3.7 RAG 텍스트 검색 알고리즘 구현 (핵심!)

```python
def _search_similar(self, query: str, top_k: int = 3):
    """유사한 텍스트 문서 검색 (RAG)"""
    try:
        # 1. 쿼리 임베딩 생성
        query_embedding = self._create_embedding(query)

        if not query_embedding:
            return []

        # 2. ChromaDB에서 유사도 검색
        results = self.text_collection.query(
            query_embeddings=[query_embedding],
            n_results=top_k
        )

        # 3. 결과 파싱
        documents = []
        if results and results['documents']:
            for doc in results['documents'][0]:
                documents.append(doc)

        return documents

    except Exception as e:
        print(f"텍스트 검색 실패: {e}")
        return []
```

**체크리스트**:

- [ ] 쿼리 임베딩 생성
- [ ] ChromaDB 유사도 검색
- [ ] 상위 K개 문서 반환
- [ ] 유사도 임계값 설정 (선택)

### 3.8 RAG 이미지 검색 알고리즘 구현 (필수!)

```python
def _search_similar_image(self, query: str, top_k: int = 2):
    """유사한 이미지 검색 (RAG)"""
    try:
        # 1. 쿼리 임베딩 생성
        query_embedding = self._create_embedding(query)

        if not query_embedding:
            return None

        # 2. ChromaDB에서 이미지 유사도 검색
        results = self.image_collection.query(
            query_embeddings=[query_embedding],
            n_results=top_k
        )

        # 3. 가장 유사한 이미지 반환
        if results and results['metadatas'] and len(results['metadatas'][0]) > 0:
            best_match = results['metadatas'][0][0]
            return best_match.get('filename')

        return None

    except Exception as e:
        print(f"이미지 검색 실패: {e}")
        return None
```

**체크리스트**:

- [ ] 쿼리 임베딩 생성
- [ ] 이미지 컬렉션에서 유사도 검색
- [ ] 가장 관련성 높은 이미지 파일명 반환
- [ ] 에러 핸들링

**Docker에서 테스트**:

```bash
# 챗봇에게 "캠퍼스 지도 보여줘" 같은 질문으로 이미지 검색 테스트
```

### 3.9 프롬프트 구성

```python
def _build_prompt(self, user_message: str, context_docs: list) -> str:
    """시스템 프롬프트 + RAG 컨텍스트 + 사용자 메시지 결합"""

    # 챗봇 설정 로드
    config = self._load_config()
    system_prompt = config.get("system_prompt", "")

    # RAG 컨텍스트 구성
    context = "\n\n".join([f"[참고 {i+1}] {doc}" for i, doc in enumerate(context_docs)])

    # 최종 프롬프트
    final_prompt = f"""
{system_prompt}

다음은 참고할 수 있는 정보입니다:
{context}

사용자 질문: {user_message}

위 정보를 바탕으로 친절하게 답변해주세요. 관련된 이미지가 있다면 보여주세요.
"""

    return final_prompt
```

**체크리스트**:

- [ ] chatbot_config.json에서 시스템 프롬프트 로드
- [ ] RAG 컨텍스트 포맷팅
- [ ] 프롬프트 템플릿 구성

### 3.10 응답 생성 파이프라인 (통합) - 이미지 검색 포함!

```python
def generate_response(self, user_message: str, username: str = "사용자") -> dict:
    """최종 응답 생성 (텍스트 + 이미지)"""
    try:
        # 1. 텍스트 RAG 검색
        context_docs = self._search_similar(user_message, top_k=3)

        # 2. 이미지 RAG 검색 (필수!)
        image_filename = self._search_similar_image(user_message, top_k=2)

        # 3. 프롬프트 구성
        prompt = self._build_prompt(user_message, context_docs)

        # 4. LLM API 호출
        response = self.client.chat.completions.create(
            model="gpt-4o-mini",  # 또는 "gpt-4"
            messages=[
                {"role": "system", "content": self._load_config().get("system_prompt")},
                {"role": "user", "content": prompt}
            ],
            temperature=0.7,
            max_tokens=500
        )

        # 5. 응답 추출
        reply = response.choices[0].message.content

        return {
            "reply": reply,
            "image": image_filename  # 이미지 파일명 반환 (필수!)
        }

    except Exception as e:
        print(f"응답 생성 실패: {e}")
        return {
            "reply": "죄송해요, 지금은 답변하기 어려워요. 😅",
            "image": None
        }
```

**체크리스트**:

- [ ] 텍스트 RAG 검색 호출
- [ ] **이미지 RAG 검색 호출 (필수!)**
- [ ] 프롬프트 구성
- [ ] OpenAI Chat Completions API 호출
- [ ] 응답 파싱 및 반환 (텍스트 + 이미지)
- [ ] 에러 핸들링

**완료 기준**:

- `chatbot_service.py`의 모든 메서드 구현 완료
- **이미지 검색 기능 정상 작동**
- Docker 환경에서 모든 기능 테스트 완료

---

## ✅ Task 4: Docker 환경에서 로컬 테스트

**⚠️ 중요**: 모든 개발과 테스트는 Docker 환경에서 진행되어야 합니다!

### 4.1 Docker 빌드 및 실행

```bash
# Docker Desktop이 실행 중인지 반드시 확인!

# 프로젝트 폴더로 이동
cd /Users/jeonsiwon/Desktop/3-chatbot-project

# Docker 컨테이너 빌드 및 실행
docker compose up --build
```

**⚠️ Docker 필수 체크**:

- [ ] Docker Desktop이 실행 중인가?
- [ ] `docker compose up --build` 명령어가 에러 없이 실행되는가?
- [ ] Flask 서버가 정상적으로 시작되었는가?
- [ ] 포트 5001이 사용 가능한가?

**체크리스트**:

- [ ] Docker Desktop 실행 확인
- [ ] `docker compose up --build` 실행
- [ ] 빌드 에러 없이 완료
- [ ] Flask 서버 시작 로그 확인
- [ ] "Running on http://0.0.0.0:5001" 메시지 확인

### 4.2 Docker 환경에서 웹 브라우저 테스트

- [ ] 브라우저에서 `http://localhost:5001` 접속
- [ ] 메인 페이지 로딩 확인
- [ ] 채팅 페이지로 이동
- [ ] 챗봇과 대화 테스트 (최소 10개 질문)

**테스트 시나리오** (반드시 Docker 컨테이너 실행 상태에서!):

1. **간단한 인사** → 챗봇이 자연스럽게 응답하는지 확인
2. **지식 베이스에 있는 질문** → RAG가 제대로 작동하는지 확인
3. **이미지 요청 질문** → "캠퍼스 지도 보여줘", "도서관 사진 보여줘" 등 (필수!)
4. **지식 베이스에 없는 질문** → 적절히 대응하는지 확인
5. **연속된 대화** → 맥락을 유지하는지 확인 (선택)
6. **엣지 케이스** → 빈 메시지, 긴 메시지 등
7. **다양한 카테고리 질문** → 학식, 시설, 학사, 동아리 등
8. **이미지 검색 정확도** → 질문에 맞는 이미지가 표시되는지 확인
9. **복합 질문** → "도서관 어디있어? 사진도 보여줘"
10. **성능 테스트** → 응답 시간 3초 이내인지 확인

### 4.3 Docker 환경에서 디버깅

Docker 컨테이너의 로그를 확인하여 에러를 찾고 수정:

```bash
# 터미널에서 실시간 로그 확인
# Ctrl+C로 중지하지 말고 다른 터미널 창을 열어서 확인

# 에러가 발생하면:
# 1. 에러 메시지를 읽고 원인 파악
# 2. 코드를 수정 (Docker volumes 덕분에 실시간 반영됨)
# 3. Flask가 자동으로 재시작되는 것 확인
# 4. 브라우저에서 다시 테스트

# 심각한 에러가 있어서 컨테이너를 재시작해야 한다면:
# Ctrl+C로 중지 후
docker compose down
docker compose up --build
```

**Docker 디버깅 팁**:

- `volumes` 설정 덕분에 코드 수정은 즉시 반영됩니다
- 새 라이브러리를 추가했다면 `--build` 옵션으로 재빌드하세요
- 로그는 터미널에서 실시간으로 확인 가능합니다
- ChromaDB 데이터는 `static/data/chatbot/chardb_embedding/`에 저장됩니다

**완료 기준**:

- Docker 환경에서 챗봇이 정상 작동
- 모든 테스트 시나리오 통과
- **이미지 검색 기능 정상 작동**
- 콘솔에 치명적인 에러 없음

---

## ✅ Task 5: Vercel CLI를 통한 배포

**주의**: 배포 전에 Docker 환경에서 충분히 테스트하세요!

### 5.1 Vercel CLI 설치

```bash
# npm을 사용하여 Vercel CLI 설치
npm install -g vercel
```

**체크리스트**:

- [ ] Vercel CLI 설치 완료
- [ ] `vercel --version` 실행하여 설치 확인

### 5.2 Vercel 로그인

```bash
vercel login
```

- [ ] Vercel 계정으로 로그인 (GitHub, GitLab, Bitbucket, Email 중 선택)
- [ ] 인증 완료

### 5.3 환경 변수 설정 (중요!)

Vercel에 OpenAI API 키를 등록해야 합니다:

```bash
# 방법 1: CLI로 설정
vercel env add OPENAI_API_KEY

# 프롬프트가 나오면:
# - Value: [실제 OpenAI API 키 입력]
# - Environment: Production, Preview, Development 모두 선택
```

또는 Vercel 웹 대시보드에서 설정:

- [ ] https://vercel.com/dashboard 접속
- [ ] 프로젝트 선택 → Settings → Environment Variables
- [ ] `OPENAI_API_KEY` 추가

### 5.4 프로젝트 배포 (Preview)

```bash
# 프로젝트 폴더에서 실행
cd /Users/jeonsiwon/Desktop/3-chatbot-project

# Preview 배포 (테스트용)
vercel
```

**배포 프로세스**:

1. 프로젝트 설정 확인 (기존 프로젝트 링크 또는 새 프로젝트 생성)
2. 빌드 및 배포
3. Preview URL 생성 (예: `https://chatbot-project-xxx.vercel.app`)

**체크리스트**:

- [ ] 배포 성공 메시지 확인
- [ ] Preview URL 접속
- [ ] 웹사이트가 정상 작동하는지 확인
- [ ] 챗봇 기능 테스트 (텍스트 + 이미지)

### 5.5 프로덕션 배포

Preview 배포가 성공했다면, 프로덕션으로 배포:

```bash
vercel --prod
```

**체크리스트**:

- [ ] 프로덕션 배포 성공
- [ ] 프로덕션 URL 확인 (예: `https://chatbot-project.vercel.app`)
- [ ] 프로덕션 환경에서 최종 테스트

### 5.6 배포 검증

- [ ] 프로덕션 URL에서 모든 기능 테스트
- [ ] **이미지 검색 기능이 프로덕션에서도 작동하는지 확인**
- [ ] 모바일 브라우저에서도 테스트
- [ ] 다양한 브라우저에서 테스트 (Chrome, Safari, Firefox)
- [ ] API 응답 시간 확인 (3초 이내)

**완료 기준**:

- 프로덕션 URL에서 챗봇이 정상 작동
- 텍스트 + 이미지 검색 모두 정상 작동
- 모든 기능 검증 완료

---

## ✅ Task 6: 최종 점검 및 문서화

### 6.1 코드 정리

- [ ] 불필요한 주석 제거
- [ ] 코드 포맷팅 (Black, Prettier 등 사용)
- [ ] 디버그 print문 제거 또는 logging으로 변경
- [ ] Docker 환경에서 최종 테스트

### 6.2 README 업데이트 (선택)

자신만의 README 섹션 추가:

- [ ] 챗봇 소개 및 특징
- [ ] 배포 URL 링크
- [ ] 스크린샷 추가 (이미지 검색 기능 포함)
- [ ] 사용 기술 상세 설명
- [ ] Docker 기반 개발 환경 설명

### 6.3 Git 커밋 및 푸시

```bash
git add .
git commit -m "완성: 챗봇 프로젝트 구현 및 배포 (이미지 검색 기능 포함)"
git push origin main
```

### 6.4 최종 체크리스트

- [ ] 모든 Task 완료
- [ ] **Docker 환경에서 모든 기능 테스트 완료**
- [ ] **이미지 검색 기능 정상 작동 확인**
- [ ] **최소 50개 이상의 텍스트 데이터 작성 완료**
- [ ] **최소 10개 이상의 이미지 데이터 준비 완료**
- [ ] Vercel 프로덕션 배포 완료
- [ ] 배포된 사이트 정상 작동 확인
- [ ] Git 저장소 최신 상태 유지

---

## 🎉 완료!

축하합니다! Docker 기반으로 챗봇 프로젝트를 성공적으로 완성하고 배포했습니다.

### 다음 단계 (선택)

1. **고급 기능 추가**: ADVANCED_TOPICS.md 참고
2. **성능 최적화**: 응답 속도 개선, 캐싱 추가
3. **모니터링**: Vercel Analytics, Sentry 등 연동
4. **기능 확장**: 멀티모달 응답, 음성 인식 등

---

## 📚 참고 자료

- **프로젝트 구조**: [ARCHITECTURE.md](../ARCHITECTURE.md)
- **Docker 가이드**: [DOCKER-GUIDE.md](../DOCKER-GUIDE.md)
- **고급 주제**: [ADVANCED_TOPICS.md](../ADVANCED_TOPICS.md)
- **Vercel 공식 문서**: https://vercel.com/docs
- **OpenAI API 문서**: https://platform.openai.com/docs
- **ChromaDB 문서**: https://docs.trychroma.com/

---

## 🐛 문제 해결

### Docker 관련

- **문제**: Docker가 실행되지 않음
- **해결**: Docker Desktop을 실행하고 재시도. 시스템 재시작 필요할 수도 있음

- **문제**: 포트 5001이 이미 사용 중
- **해결**: `docker-compose.yml`에서 포트 변경 또는 기존 프로세스 종료

- **문제**: 코드 수정이 반영되지 않음
- **해결**: Flask의 자동 재로드 확인. volumes 설정 확인

### API 키 관련

- **문제**: OpenAI API 에러
- **해결**: `.env` 파일과 Vercel 환경 변수 확인. API 키 유효성 확인

### 배포 관련

- **문제**: Vercel 빌드 실패
- **해결**: requirements.txt, vercel.json 확인. 로그 상세 분석

### 챗봇 응답 관련

- **문제**: 챗봇이 관련 없는 답변을 함
- **해결**: system_prompt와 RAG 검색 로직 개선. 데이터 품질 향상

### 이미지 검색 관련

- **문제**: 이미지가 표시되지 않음
- **해결**: `image_metadata.json` 확인. 이미지 파일 경로 확인. 임베딩 생성 로그 확인

- **문제**: 잘못된 이미지가 표시됨
- **해결**: 이미지 메타데이터의 keywords 개선. 더 구체적인 설명 추가
